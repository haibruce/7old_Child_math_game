<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ€ªç‰©ç®—è¡“å¤§å†’éšª</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif;
            touch-action: manipulation;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s ease-out; 
        }
        canvas {
            background: linear-gradient(to bottom, #1e1b4b, #1e293b);
            display: block;
            border-bottom: 3px solid #6366f1;
            width: 100%;
            height: 75vh; 
            transition: border-color 0.3s, border-width 0.3s;
        }
        .canvas-dead {
            border-bottom: 12px solid #ef4444 !important;
            box-shadow: 0 0 20px #ef4444;
        }
        .ui-panel {
            position: absolute;
            top: 10px;
            width: 100%;
            padding: 0 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: white;
            z-index: 10;
            pointer-events: none;
        }
        .menu-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: white;
            text-align: center;
        }
        .btn {
            transition: transform 0.1s, background-color 0.2s;
            cursor: pointer;
            pointer-events: auto;
        }
        .btn:active {
            transform: scale(0.9);
        }
        .mode-btn.selected {
            background-color: #eab308;
            color: black;
            font-weight: bold;
        }
        .option-btn {
            height: 50px;
            font-size: 1.25rem; 
            font-weight: 700;
        }
        #controls-container {
            flex: 1;
            width: 100%;
            background-color: #0f172a;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
        .back-btn, .bomb-btn, .test-trigger-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 13px;
            color: white;
        }
        .bomb-btn {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .speed-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            color: white;
        }
        .speed-btn.active {
            background: #eab308;
            color: #000;
            border-color: #facc15;
            box-shadow: 0 0 15px rgba(234, 179, 8, 0.5);
        }
        .bottom-ui {
            position: absolute;
            bottom: 26vh;
            width: 100%;
            padding: 0 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 20;
        }
        .popover-menu {
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 12px;
            padding: 8px;
            display: none;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            margin-bottom: 8px;
        }
        .popover-item {
            padding: 8px 16px;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            text-align: center;
            white-space: nowrap;
        }
        .popover-item:hover {
            background: #334155;
        }
        @keyframes fadeUp {
            0% { opacity: 0; transform: translate(-50%, 0); }
            20% { opacity: 0.7; transform: translate(-50%, -20px); }
            80% { opacity: 0.7; transform: translate(-50%, -40px); }
            100% { opacity: 0; transform: translate(-50%, -60px); }
        }
        .stage-msg {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 2rem;
            font-weight: 900;
            white-space: nowrap;
            pointer-events: none;
            z-index: 50;
            animation: fadeUp 2.5s forwards;
        }
        .boss-win-msg {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #facc15;
            font-size: 2.5rem;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(0,0,0,0.8), 0 0 10px rgba(234,179,8,0.5);
            white-space: nowrap;
            pointer-events: none;
            z-index: 60;
            animation: bossWinAnim 3s forwards;
        }
        @keyframes bossWinAnim {
            0% { opacity: 0; transform: translate(-50%, -20%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            20% { transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(0.8); }
        }
        #danger-text, #boss-warning-text {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 1.5rem;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 20;
            display: none;
            white-space: nowrap;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="danger-text">è¶•å¿«! æ€ªç‰©å¿«è¦å’¬åˆ°ä½ äº†</div>
    <div id="boss-warning-text">è­¦å‘Šï¼Œé­”ç‹æ¥è¿‘ä¸­!!</div>
    
    <div class="ui-panel">
        <div class="flex flex-col gap-2">
            <div class="flex items-center gap-2">
                <button onclick="backToMenu()" id="ingame-back-btn" class="back-btn btn hidden">â†© è¿”å›</button>
                <div class="bg-black/50 px-3 py-1 rounded-full border border-white/10">
                    <span class="text-indigo-300 text-xs font-bold">å¾—åˆ†:</span> <span id="score-display" class="text-lg ml-1 font-mono">0</span>
                </div>
            </div>
            <button onclick="useBomb()" id="bomb-btn" class="bomb-btn btn hidden">ğŸ’£ ç‚¸å½ˆ x<span id="bomb-count">0</span></button>
        </div>
        
        <div class="flex flex-col items-end gap-2">
            <div class="bg-black/50 px-3 py-1 rounded-full border border-white/10">
                <span id="hp-display" class="text-lg">â¤ï¸â¤ï¸â¤ï¸</span>
            </div>
            <button onclick="toggleSpeed()" id="speed-btn" class="speed-btn btn hidden">âš¡ åŠ é€Ÿ</button>
        </div>
    </div>

    <div class="bottom-ui">
        <div id="test-ui-group" class="hidden flex flex-col items-start">
            <div id="test-menu" class="popover-menu">
                <button class="popover-item btn" onclick="devAction('score')">åŠ  100 åˆ†</button>
                <button class="popover-item btn" onclick="devAction('stage')">è·³è½‰ä¸‹ä¸€éšæ®µ</button>
                <button class="popover-item btn" onclick="devAction('boss')">å¼·åˆ¶é€²å…¥ BOSS</button>
                <button class="popover-item btn" onclick="devAction('hp')">å¢åŠ ç”Ÿå‘½å€¼</button>
                <button class="popover-item btn" onclick="devAction('bomb')">å¢åŠ ç‚¸å½ˆ</button>
            </div>
            <button id="test-btn" class="test-trigger-btn btn" onclick="handleTestClick()">ğŸ› ï¸ æ¸¬è©¦</button>
        </div>

        <div id="speed-gear-group" class="hidden flex flex-col items-end">
            <div id="gear-menu" class="popover-menu">
                <button class="popover-item btn" onclick="setGear(2)">2 å€</button>
                <button class="popover-item btn" onclick="setGear(4)">4 å€</button>
                <button class="popover-item btn" onclick="setGear(8)">8 å€</button>
                <button class="popover-item btn" onclick="setGear(16)">16 å€</button>
                <button class="popover-item btn" onclick="setGear(32)">32 å€</button>
            </div>
            <div class="flex items-center gap-2 pointer-events-auto">
                <span id="gear-status" class="text-xs font-bold text-yellow-400 bg-black/40 px-2 py-1 rounded">æª”ä½: 3x</span>
                <button class="speed-btn btn" onclick="toggleGearMenu()">âš™ï¸ åŠ é€Ÿåº¦æ’æª”</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="stage-msg-container"></div>

    <div id="controls-container">
        <div id="controls" class="grid grid-cols-4 gap-3 w-full max-w-lg"></div>
    </div>

    <div id="menu" class="menu-overlay">
        <h1 class="text-4xl font-black mb-2 text-yellow-400">æ€ªç‰©ç®—è¡“å¤§å†’éšª</h1>
        <div id="last-score-container" class="mb-6 hidden">
            <p class="text-indigo-300 text-sm">ä¸Šæ¬¡éŠç©å¾—åˆ†ï¼š<span id="last-score-val" class="font-bold text-xl text-white">0</span></p>
        </div>

        <div class="mb-6">
            <p class="text-slate-400 text-xs mb-2">æ¨¡å¼é¸æ“‡</p>
            <div class="flex gap-2">
                <button id="mode-add" onclick="setMode('add')" class="mode-btn btn selected bg-slate-700 px-6 py-2 rounded-lg text-sm">åŠ æ³• (+)</button>
                <button id="mode-sub" onclick="setMode('sub')" class="mode-btn btn bg-slate-700 px-6 py-2 rounded-lg text-sm">æ¸›æ³• (âˆ’)</button>
            </div>
        </div>
        
        <div class="flex flex-col gap-2 w-64">
            <button onclick="startGame('easy')" class="btn bg-emerald-500 py-3 rounded-xl font-bold shadow-lg">ç°¡å–®æ¨¡å¼ (1-10)</button>
            <button onclick="startGame('medium')" class="btn bg-sky-500 py-3 rounded-xl font-bold shadow-lg">æ™®é€šæ¨¡å¼ (1-50)</button>
            <button onclick="startGame('hard')" class="btn bg-rose-500 py-3 rounded-xl font-bold shadow-lg">å›°é›£æ¨¡å¼ (1-100)</button>
        </div>
    </div>

    <div id="game-over" class="menu-overlay hidden">
        <div class="bg-slate-800 p-10 rounded-3xl border border-indigo-500 shadow-2xl">
            <h2 class="text-3xl font-black text-white mb-2 italic">æŒ‘æˆ°çµæŸ</h2>
            <p class="text-lg mb-8 text-slate-400">æœ€çµ‚å¾—åˆ†ï¼š<span id="final-score" class="text-yellow-400 font-bold text-3xl">0</span></p>
            <button onclick="backToMenu()" class="btn bg-indigo-500 text-white px-12 py-3 rounded-full font-bold shadow-lg">å›åˆ°ä¸»é¸å–®</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const scoreDisplay = document.getElementById('score-display');
    const hpDisplay = document.getElementById('hp-display');
    const bombCountDisplay = document.getElementById('bomb-count');
    const menu = document.getElementById('menu');
    const gameOverScreen = document.getElementById('game-over');
    const controls = document.getElementById('controls');
    const backBtn = document.getElementById('ingame-back-btn');
    const speedBtn = document.getElementById('speed-btn');
    const bombBtn = document.getElementById('bomb-btn');
    const testUi = document.getElementById('test-ui-group');
    const gearUi = document.getElementById('speed-gear-group');
    const gearStatus = document.getElementById('gear-status');
    const stageMsgContainer = document.getElementById('stage-msg-container');
    const dangerText = document.getElementById('danger-text');
    const bossWarningText = document.getElementById('boss-warning-text');

    let gameActive = false;
    let score = 0;
    let hp = 3;
    let bombs = 0;
    let difficulty = 'easy';
    let gameMode = 'add'; 
    let monsters = [];
    let particles = [];
    let currentProblem = null;
    let lastTime = 0;
    let spawnTimer = 0;
    let spawnInterval = 4000; 
    let animationFrameId = null;
    let arrowBounce = 0;
    let lastStageMilestone = 0;
    let nextBossScore = 500;
    
    let isSpeedUp = false;
    let currentGear = 3; 
    let isBossWarning = false;
    let isBossActive = false;
    let isEnding = false;

    // BOSS ç‰¹æ®Šç‹€æ…‹ç®¡ç†
    let bossAttackState = 'IDLE'; 
    let bossAttackTimer = 0;

    let testClicks = 0;
    let testClickTimer = null;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight * 0.75;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function handleTestClick() {
        testClicks++;
        clearTimeout(testClickTimer);
        testClickTimer = setTimeout(() => { testClicks = 0; }, 1000);
        if (testClicks >= 5) {
            const m = document.getElementById('test-menu');
            m.style.display = (m.style.display === 'flex') ? 'none' : 'flex';
            testClicks = 0;
        }
    }

    function toggleGearMenu() {
        const m = document.getElementById('gear-menu');
        m.style.display = (m.style.display === 'flex') ? 'none' : 'flex';
    }

    function setGear(val) {
        currentGear = val;
        gearStatus.innerText = `æª”ä½: ${val}x`;
        document.getElementById('gear-menu').style.display = 'none';
    }

    function devAction(type) {
        if (type === 'score') {
            score += 100; checkMilestones();
        } else if (type === 'stage') {
            score = (Math.floor(score / 200) + 1) * 200;
            lastStageMilestone = score;
            triggerStageUp();
            checkMilestones();
        } else if (type === 'boss') {
            triggerBossWarning();
        } else if (type === 'hp') {
            hp++;
        } else if (type === 'bomb') {
            bombs++;
        }
        updateUI();
        document.getElementById('test-menu').style.display = 'none';
    }

    function setMode(mode) {
        gameMode = mode;
        document.getElementById('mode-add').classList.toggle('selected', mode === 'add');
        document.getElementById('mode-sub').classList.toggle('selected', mode === 'sub');
    }

    function toggleSpeed() {
        isSpeedUp = !isSpeedUp;
        speedBtn.innerText = isSpeedUp ? `âš¡ åŠ é€Ÿä¸­` : "âš¡ åŠ é€Ÿ";
        speedBtn.classList.toggle('active', isSpeedUp);
    }

    function useBomb() {
        if (bombs <= 0 || !gameActive || isBossWarning) return;
        bombs--;
        updateUI();
        monsters = monsters.filter(m => m.isBoss);
        if (monsters.length === 0) {
            currentProblem = null;
            controls.innerHTML = '';
        } else if (!monsters.includes(currentProblem)) {
            updateOptions(monsters[0]);
        }
    }

    class Particle {
        constructor(x, y) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 8 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.size = Math.random() * 6 + 2;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.02; }
        draw() {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.life})`;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        }
    }

    class Monster {
        constructor(n1, n2, type, baseSpeed, isBoss = false) {
            this.n1 = n1; this.n2 = n2;
            this.type = type === '+' ? '+' : 'âˆ’';
            this.answer = type === '+' ? (n1 + n2) : (n1 - n2);
            this.isBoss = isBoss;
            this.hp = isBoss ? 10 : 1; 
            this.baseSpeed = baseSpeed * 0.35; 
            const baseSize = Math.min(canvas.width, canvas.height) * 0.14;
            this.radius = isBoss ? baseSize * 1.5 : baseSize; 
            this.x = isBoss ? canvas.width / 2 : (Math.random() * (canvas.width - this.radius * 2) + this.radius);
            this.y = -this.radius;
            this.color = isBoss ? '#ef4444' : `hsl(${Math.random() * 360}, 75%, 55%)`;
            this.wobble = 0;
            this.smashOffset = 0;
            this.armWobble = 0;
        }
        update(deltaTime) {
            if (isEnding) return;
            
            let speedFactor = 1;
            if (this.isBoss) {
                const threshold = canvas.height * (5/6);
                speedFactor = (this.y < threshold) ? 1.5 : 0.5;
            }
            
            const activeGear = isSpeedUp ? currentGear * 1.5 : currentGear;
            const currentSpeed = (isSpeedUp ? this.baseSpeed * activeGear : this.baseSpeed) * speedFactor;
            const stopLine = canvas.height - this.radius;

            if (this.isBoss && this.y >= stopLine) {
                this.y = stopLine;
                this.armWobble += 0.1;
                
                // BOSS ç‰¹æ®Šè¡æ’å‹•ä½œè™•ç†
                if (bossAttackState === 'PREPARING') {
                    // ç¬¬ä¸€éšæ®µï¼š0.8ç§’å‘ä¸Šç§»å‹•ä¸€å°æ®µï¼Œ0.15ç§’å›åˆ°åŸä½
                    if (bossAttackTimer < 800) {
                        // å‘ä¸Šè“„åŠ›
                        this.smashOffset = -(bossAttackTimer / 800) * 40;
                    } else if (bossAttackTimer < 950) { // 800ms + 150ms
                        // å‘ä¸‹çŒ›æ’
                        const snapBackTime = bossAttackTimer - 800;
                        this.smashOffset = -40 + (snapBackTime / 150) * 40;
                    } else {
                        this.smashOffset = 0;
                    }
                } else {
                    this.smashOffset = 0;
                }
            } else {
                this.y += currentSpeed * (deltaTime / 16);
            }

            if (!this.isBoss) {
                this.wobble += 0.05;
                this.x += Math.sin(this.wobble) * 0.4;
            }
        }
        draw(isTarget) {
            ctx.save();
            ctx.translate(this.x, this.y + (this.isBoss ? this.smashOffset : 0));
            
            if (this.isBoss) {
                this.drawArms();
            }

            ctx.beginPath(); 
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2); 
            ctx.fillStyle = this.color; 
            ctx.fill();
            
            if (isTarget) { 
                ctx.strokeStyle = '#fde047'; 
                ctx.lineWidth = this.isBoss ? 10 : 6; 
                ctx.stroke(); 
            }
            
            ctx.fillStyle = 'white';
            const eyeSize = this.isBoss ? 0.25 : 0.2;
            ctx.beginPath(); 
            ctx.arc(-this.radius*0.3, -this.radius*0.1, this.radius*eyeSize, 0, Math.PI * 2);
            ctx.arc(this.radius*0.3, -this.radius*0.1, this.radius*eyeSize, 0, Math.PI * 2); 
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-this.radius*0.3, -this.radius*0.1, this.radius*eyeSize*0.5, 0, Math.PI * 2);
            ctx.arc(this.radius*0.3, -this.radius*0.1, this.radius*eyeSize*0.5, 0, Math.PI * 2); 
            ctx.fill();

            ctx.fillStyle = 'white';
            const fontSize = Math.floor(this.radius * (this.isBoss ? 0.6 : 0.8)); 
            ctx.font = `900 ${fontSize}px "Arial Black", sans-serif`; 
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = 'black'; 
            ctx.lineWidth = 5;
            ctx.strokeText(`${this.n1}${this.type}${this.n2}`, 0, this.radius * 0.4);
            ctx.fillText(`${this.n1}${this.type}${this.n2}`, 0, this.radius * 0.4);
            
            if (this.isBoss) {
                const barW = this.radius * 1.5; 
                ctx.fillStyle = '#333'; 
                ctx.fillRect(-barW/2, -this.radius - 30, barW, 10);
                ctx.fillStyle = '#4ade80'; 
                ctx.fillRect(-barW/2, -this.radius - 30, barW * (this.hp / 10), 10);
            }
            if (isTarget) this.drawArrow();
            ctx.restore();
        }
        
        drawArms() {
            ctx.fillStyle = this.color;
            const armLen = this.radius * 0.8;
            const armWidth = this.radius * 0.4;
            const wobbleL = Math.sin(this.armWobble) * 15;
            const wobbleR = Math.cos(this.armWobble) * 15;

            ctx.save();
            ctx.translate(-this.radius * 0.8, 0);
            ctx.rotate(Math.PI / 6 + wobbleL * Math.PI / 180);
            this.drawRoundedRect(-armLen, -armWidth/2, armLen, armWidth, 15);
            ctx.restore();

            ctx.save();
            ctx.translate(this.radius * 0.8, 0);
            ctx.rotate(-Math.PI / 6 + wobbleR * Math.PI / 180);
            this.drawRoundedRect(0, -armWidth/2, armLen, armWidth, 15);
            ctx.restore();
        }

        drawRoundedRect(x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            ctx.fill();
        }

        drawArrow() {
            const bounce = Math.sin(arrowBounce) * 10; 
            const arrowY = this.radius + 20 + bounce;
            ctx.fillStyle = '#fde047'; ctx.shadowBlur = 10; ctx.shadowColor = 'black';
            ctx.beginPath(); 
            ctx.moveTo(0, arrowY); 
            ctx.lineTo(-15, arrowY + 20); 
            ctx.lineTo(15, arrowY + 20); 
            ctx.closePath();
            ctx.fill(); ctx.fillRect(-6, arrowY + 20, 12, 15); ctx.shadowBlur = 0;
        }
    }

    function resetAllData() {
        score = 0; hp = 3; bombs = 0;
        monsters = []; particles = []; currentProblem = null;
        spawnTimer = 0; lastTime = performance.now(); lastStageMilestone = 0; nextBossScore = 500;
        isSpeedUp = false; currentGear = 3; isBossWarning = false; isBossActive = false; isEnding = false;
        bossAttackState = 'IDLE'; bossAttackTimer = 0;
        gearStatus.innerText = "æª”ä½: 3x";
        speedBtn.innerText = "âš¡ åŠ é€Ÿ"; speedBtn.classList.remove('active');
        dangerText.style.display = 'none'; bossWarningText.style.display = 'none';
        canvas.classList.remove('canvas-dead');
        gameContainer.style.transform = 'translateY(0)';
        document.getElementById('test-menu').style.display = 'none';
        document.getElementById('gear-menu').style.display = 'none';
        
        if (difficulty === 'easy') spawnInterval = 4000;
        else if (difficulty === 'medium') spawnInterval = 3333;
        else spawnInterval = 2666;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        controls.innerHTML = ''; stageMsgContainer.innerHTML = '';
        updateUI();
    }

    function startGame(diff) {
        difficulty = diff;
        menu.classList.add('hidden'); gameOverScreen.classList.add('hidden');
        backBtn.classList.remove('hidden'); speedBtn.classList.remove('hidden'); bombBtn.classList.remove('hidden');
        testUi.classList.remove('hidden'); gearUi.classList.remove('hidden');
        resetAllData();
        gameActive = true;
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
        generateNewProblem();
    }

    function backToMenu() {
        gameActive = false; cancelAnimationFrame(animationFrameId);
        gameOverScreen.classList.add('hidden'); backBtn.classList.add('hidden');
        speedBtn.classList.add('hidden'); bombBtn.classList.add('hidden');
        testUi.classList.add('hidden'); gearUi.classList.add('hidden');
        menu.classList.remove('hidden'); resetAllData();
    }

    function updateUI() {
        scoreDisplay.innerText = score;
        hpDisplay.innerText = 'â¤ï¸'.repeat(Math.max(0, hp));
        bombCountDisplay.innerText = bombs;
    }

    function triggerStageUp() {
        const div = document.createElement('div');
        div.className = 'stage-msg';
        div.innerText = "æ­å–œä½ é”åˆ°ä¸‹ä¸€å€‹éšæ®µ";
        stageMsgContainer.appendChild(div);
        setTimeout(() => div.remove(), 3000);
        spawnInterval = Math.max(800, spawnInterval * 0.85); 
    }

    function checkMilestones() {
        if (score > 0 && score >= lastStageMilestone + 200) {
            lastStageMilestone = Math.floor(score / 200) * 200;
            triggerStageUp();
        }
        if (score >= nextBossScore) {
            nextBossScore += 500;
            triggerBossWarning();
        }
    }

    function triggerBossWarning() {
        if (isBossWarning || isBossActive) return;
        monsters = [];
        currentProblem = null;
        controls.innerHTML = '';
        isBossWarning = true;
        bossWarningText.style.display = 'block';
        setTimeout(() => {
            isBossWarning = false;
            bossWarningText.style.display = 'none';
            spawnBoss();
        }, 2500);
    }

    function spawnBoss() {
        isBossActive = true;
        bossAttackState = 'IDLE';
        const stageBonus = Math.floor(score / 200) * 0.1;
        const speed = 0.5 + (score / 1200) + stageBonus;
        const { n1, n2, type } = getProblemData();
        const boss = new Monster(n1, n2, type, speed, true);
        monsters.unshift(boss);
        updateOptions(boss);
    }

    function getProblemData() {
        let maxRange = difficulty === 'hard' ? 100 : (difficulty === 'medium' ? 50 : 10);
        let n1, n2; const type = gameMode === 'add' ? '+' : '-';
        if (type === '+') { n1 = Math.floor(Math.random() * maxRange) + 1; n2 = Math.floor(Math.random() * maxRange) + 1; }
        else { n1 = Math.floor(Math.random() * (maxRange - 1)) + 1; n2 = Math.floor(Math.random() * n1); }
        return { n1, n2, type };
    }

    function generateNewProblem() {
        if (!gameActive || isBossWarning || isBossActive || isEnding) return;
        const { n1, n2, type } = getProblemData();
        const stageBonus = Math.floor(score / 200) * 0.1;
        const speedMultiplier = 0.5 + (score / 1200) + stageBonus;
        const newMonster = new Monster(n1, n2, type, speedMultiplier);
        monsters.push(newMonster);
        if (!currentProblem) updateOptions(newMonster);
    }

    function updateOptions(target) {
        currentProblem = target; controls.innerHTML = '';
        if (!target) return;
        const correct = target.answer;
        let options = [correct];
        while (options.length < 4) {
            let fake = correct + (Math.floor(Math.random() * 11) - 5);
            if (fake >= 0 && !options.includes(fake)) options.push(fake);
            else if (options.length < 4) { let r = Math.floor(Math.random() * 20); if (!options.includes(r)) options.push(r); }
        }
        options.sort(() => Math.random() - 0.5);
        options.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = 'option-btn btn bg-white text-slate-900 rounded-xl shadow-md border border-slate-300 active:bg-yellow-50';
            btn.innerText = opt; btn.onclick = (e) => checkAnswer(opt, e.target);
            controls.appendChild(btn);
        });
    }

    function explodeBoss(x, y) { 
        // ç²’å­ç‰¹æ•ˆ
        for (let i = 0; i < 80; i++) particles.push(new Particle(x, y)); 
        
        // é¡¯ç¤ºå‹åˆ©æ–‡å­—
        const div = document.createElement('div');
        div.className = 'boss-win-msg';
        div.innerText = "å¤ªæ£’äº†!! é­”ç‹è¢«ä½ æ‰“æ•—äº†!";
        stageMsgContainer.appendChild(div);
        setTimeout(() => div.remove(), 3000);
    }

    function checkAnswer(val, el) {
        if (!gameActive || !currentProblem || isEnding) return;
        if (val === currentProblem.answer) {
            if (currentProblem.isBoss) {
                currentProblem.hp--;
                if (currentProblem.hp <= 0) {
                    explodeBoss(currentProblem.x, currentProblem.y);
                    monsters.splice(monsters.indexOf(currentProblem), 1);
                    isBossActive = false; hp += 3; bombs += 1;
                    bossAttackState = 'IDLE';
                    gameContainer.style.transform = 'translateY(0)';
                    updateUI();
                    if (monsters.length > 0) updateOptions(monsters[0]);
                    else { currentProblem = null; controls.innerHTML = ''; }
                } else {
                    const { n1, n2 } = getProblemData();
                    currentProblem.n1 = n1;
                    currentProblem.n2 = n2;
                    currentProblem.answer = currentProblem.type === '+' ? (n1 + n2) : (n1 - n2);
                    updateOptions(currentProblem);
                }
            } else {
                monsters.splice(monsters.indexOf(currentProblem), 1);
                score += 10; checkMilestones();
                if (monsters.length > 0) updateOptions(monsters[0]);
                else { currentProblem = null; controls.innerHTML = ''; }
                updateUI();
            }
        } else { el.classList.add('bg-red-200', 'border-red-400'); setTimeout(() => el.classList.remove('bg-red-200', 'border-red-400'), 250); }
    }

    function gameLoop(time) {
        if (!gameActive) return;
        const deltaTime = time - lastTime; lastTime = time;
        arrowBounce += 0.15;

        if (!isBossWarning && !isBossActive && !isEnding) {
            spawnTimer += deltaTime;
            if (spawnTimer > spawnInterval) { generateNewProblem(); spawnTimer = 0; }
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (isBossWarning) {
            const warningFlash = (Math.sin(time * Math.PI / 500) + 1) / 2;
            ctx.fillStyle = `rgba(220, 38, 38, ${warningFlash * 0.4})`; ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        if (!isBossWarning && currentProblem && currentProblem.y > canvas.height * 0.66) {
            const dangerLevel = (Math.sin(time * Math.PI / 1000) + 1) / 2;
            ctx.fillStyle = `rgba(220, 38, 38, ${dangerLevel * 0.3})`; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!isEnding) dangerText.style.display = 'block';
            dangerText.style.opacity = 0.5 + dangerLevel * 0.5;
        } else { dangerText.style.display = 'none'; }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update(); particles[i].draw(); if (particles[i].life <= 0) particles.splice(i, 1);
        }

        for (let i = monsters.length - 1; i >= 0; i--) {
            const m = monsters[i]; const isTarget = (m === currentProblem);
            m.update(deltaTime); m.draw(isTarget);

            const stopLine = canvas.height - m.radius;
            if (m.y >= stopLine) {
                if (m.isBoss) {
                    handleBossAttackCycle(deltaTime);
                } else {
                    hp--;
                    monsters.splice(i, 1);
                    updateUI();
                    if (currentProblem === m) currentProblem = null;
                }
                
                if (hp <= 0 && !isEnding) {
                    triggerEndingEffect();
                }
            }
        }
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function handleBossAttackCycle(dt) {
        bossAttackTimer += dt;
        
        switch(bossAttackState) {
            case 'IDLE':
                bossAttackState = 'PREPARING';
                bossAttackTimer = 0;
                break;
                
            case 'PREPARING':
                // èª¿æ•´ï¼šç¬¬ä¸€éšæ®µå‹•ä½œ 0.8s å‘ä¸Š, 0.15s å‘ä¸‹ï¼Œç¸½è¨ˆ 0.95s
                if (bossAttackTimer >= 950) {
                    bossAttackState = 'SHAKING';
                    bossAttackTimer = 0;
                }
                break;
                
            case 'SHAKING':
                if (bossAttackTimer < 1500) {
                    const shakeY = Math.sin(bossAttackTimer * Math.PI / 150) * 15;
                    gameContainer.style.transform = `translateY(${shakeY}px)`;
                } else {
                    gameContainer.style.transform = 'translateY(0)';
                    bossAttackState = 'WAITING';
                    bossAttackTimer = 0;
                }
                break;
                
            case 'WAITING':
                if (bossAttackTimer >= 300) {
                    hp--;
                    updateUI();
                    bossAttackState = 'COOLING';
                    bossAttackTimer = 0;
                }
                break;
                
            case 'COOLING':
                if (bossAttackTimer >= 2000) {
                    bossAttackState = 'PREPARING';
                    bossAttackTimer = 0;
                }
                break;
        }
    }

    function triggerEndingEffect() {
        isEnding = true;
        hp = 0;
        updateUI();
        dangerText.style.display = 'none';
        gameContainer.style.transform = 'translateY(0)';
        canvas.classList.add('canvas-dead');
        setTimeout(() => {
            endGame();
        }, 1500);
    }

    function endGame() {
        gameActive = false; document.getElementById('final-score').innerText = score;
        gameOverScreen.classList.remove('hidden'); backBtn.classList.add('hidden');
        speedBtn.classList.add('hidden'); bombBtn.classList.add('hidden');
        testUi.classList.add('hidden'); gearUi.classList.add('hidden');
        dangerText.style.display = 'none'; bossWarningText.style.display = 'none';
    }
</script>

</body>
</html>